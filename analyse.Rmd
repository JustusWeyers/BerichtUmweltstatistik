---
title: "Umweltstatistik Bericht - R"
author: "Milena Mensching und Justus Weyers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
---

# Technisches

## Pakete laden

```{r, warning=FALSE, message=FALSE}
# Das Tidyverse
library(tidyverse)

# Plots
library(GGally)
library(corrplot)

# Statistik
library(Metrics)

# Geo-Pakete
library(sf)
library(tmap)

# Lineare Modelle
library(glmulti)
library(car) # vif
library(visreg)

# Baumbasierte Modelle
library(tree)
library(randomForest)
library(quantregForest)
```

## Einstellungen

```{r, warning = FALSE, message=FALSE}
# Seed festlegen
set.seed(1)
# Kartenansicht auf interaktiv einstellen
tmap::tmap_mode("view")
```

## Funktionsdefinitionen

```{r}
# Funktion, um Modellvorhersage und Fehler an 
# den zentralen Dataframe 'data' anzubinden
pred = function(name, model, predictors = NA, data, response, 
                predictions = NULL) {
  # Vorhersagespalte anlegen
  data[,name] = rep(NA, nrow(data))
  # Fehlerspalte anlegen
  data[,paste0("err", name)] = rep(NA, nrow(data))
    
  if (!is.null(predictions)) {
    data[as.double(names(predictions)),name] = predictions
  } else {
    # Vorhersagewerte bestimmen
    predictions = predict(model, newdata = predictors)
    
    # Vorhersage anbinden
    data[rownames(predictors),name] = predictions
  }
  
  # Eigentliche Werte 
  actual = data[!is.na(data[,name]), response]
  # Fehler anbinden
  data[!is.na(data[,name]),paste0("err", name)] = (predictions - actual)**2
  
  return(data)
}

# Funktion zur Berechnung von Gesamtvarianz (SST), 
# nicht-erklärter Varianz (SSE) und R²
var = function(yobs, ymod) {
  SST = sum((yobs - mean(yobs))^2)
  SSE = sum((yobs - ymod)^2)
  R2 = 1-SSE/SST
  vec = setNames(c(SST, SSE, R2), c("SST", "SSE", "R2"))
  return(vec)
}

# Funktion, um aus einem Dataframe ein 
# simple feature zu erstellen
sf = function(df) {
  st_as_sf(df, coords = c("x_UTM", "y_UTM"), crs = st_crs(25833))
}
```

## Daten einlesen

```{r}
# Inputdatei
path = "Data/data.txt"

# Response-Variable
response = "Bodenfeuchte_Prozent"

# Alles Einlesen
readin = read.table(path, header = TRUE)

# Variablen von Interesse auswählen
data = readin |> 
  select(Punkt, Jahr, Stratum, x_UTM, y_UTM,
         Tiefe_zum_Oxidationshorizont_cm, 
         Maechtigkeit_Oxidationshorizont_cm, 
         Maechtigkeit_A_Horizont_cm,
         Maechtigkeit_AL_Schicht_cm,
         Gelaendehoehe_m,
         Bodenfeuchte_Prozent)

# Modelldaten selektieren
modeldata =  data |> 
  select(Tiefe_zum_Oxidationshorizont_cm,
         Maechtigkeit_Oxidationshorizont_cm, 
         Maechtigkeit_A_Horizont_cm,
         Maechtigkeit_AL_Schicht_cm,
         Gelaendehoehe_m,
         Bodenfeuchte_Prozent) |> 
  na.omit()

# Prädiktoren selektieren
predictors = modeldata |> 
  select(-one_of(response))

# Kartenansicht der Daten
tm_shape(sf(data)) + tm_dots(col = response)
```

## Dataframe bearbeiten

Hier sind ein paar unabhängige Änderungen am Dataframe 'data' platziert.

```{r}
# Neue Spalte anlegen mit Namen der Straten
data = data %>%
  mutate(StratumName = case_when(
    Stratum == 1 ~ "Talsand",
    Stratum == 2 ~ "Übergang",
    Stratum == 3 ~ "Feuchtwiese"
    ))
```

# Datenexploration

```{r, warning = FALSE, message=FALSE}
# Korrelationsmatrix
# ggpairs(modeldata)

# Alternativ:
# cor_model = cor(modeldata, use = "pairwise.complete.obs")
# p_values = cor.mtest(modeldata, conf.level = 0.95)
# corrplot(cor_model, p.mat = p_values$p, insig = 'p-value', sig.level = -1)
```

# Lineare Modelle

## Einfaches lineares Modell

```{r}
# Modellerstellung
linModel = lm(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "linModel", model = linModel, predictors = predictors, 
            data = data, response = response)
# RMSE
rmse(actual = data[!is.na(data$linModel), response], 
     predicted = data[!is.na(data$linModel), "linModel"])
# VIF
vif(linModel)
```

## Bestes lineares Modell

```{r}
# Mögliche lineare Modelle nach Güte untersuchen und ordnen
res = glmulti(linModel, level = 1, method = "h", confsetsize = 8, crit = "AIC")
# AICs
plot(res)
mean(res@crits)
# Wichtigkeit von Prädiktoren
plot(res, type = "s")

# Das beste Modell
bestlinModel = res@objects[[1]]
summary(bestlinModel)
plot(bestlinModel)
# visreg(bestModel) #?!

# Vorhersage und Fehler speichern
data = pred(name = "bestlinModel", model = bestlinModel, 
            predictors = predictors, data = data, 
            response = response)
var(yobs = data[!is.na(data$bestlinModel), response], ymod = na.omit(data$bestlinModel))
# RMSE
rmse(actual = data[!is.na(data$bestlinModel), response], 
     predicted = data[!is.na(data$bestlinModel), "bestlinModel"])
```

## Plots Lineare Modelle

```{r}
ggplot(data |> drop_na(linModel), aes(x = Bodenfeuchte_Prozent, y = linModel)) +
  geom_point(aes(col = StratumName))

ggplot(data |> drop_na(errlinModel), aes(x = StratumName, y = errlinModel)) +
  geom_boxplot(aes(fill = StratumName))

tm_shape(sf(data)) + tm_dots(col = "bestlinModel")
```

# Baumbasierte Modelle

## CART

```{r}
# Baum erstellen
treeModel = tree(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "treeModel", model = treeModel, 
            predictors = predictors, data = data, 
            response = response)
# Baumplot
{plot(treeModel);text(treeModel)}
```

## Random Forest

```{r}
# Wald anlegen
randomForest = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata)

# OOB-INB Geschichte
oob = predict(randomForest)
data = pred(name = "OOB", predictions = oob, data = data, response = response)

inb = predict(randomForest, newdata = predictors)
data = pred(name = "INB", predictions = inb, data = data, response = response)

var(yobs = data[!is.na(data$OOB), response], ymod = na.omit(data$OOB))
var(yobs = data[!is.na(data$INB), response], ymod = na.omit(data$INB))

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("OOB", "INB"), names_to='Vorhersagetyp', 
               values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Vorhersagetyp)) +
  geom_point() +
  scale_color_manual(values = c("palegreen4", "palegreen2")) +
  theme_bw()

# Variableneinfluss
importance = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata, 
                          importance = TRUE)
varImpPlot(importance, type = "1")
```

# Diskussion

## Vergleich Fehler 

Vergleich der Fehler der verwendeten Modelle in Abhängigkeit vom Stratum.

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("errlinModel", "errbestlinModel", "errtreeModel", "errOOB", "errINB"), 
               names_to='Modeltype', values_to='SquaredError') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(SquaredError) |>
  # ggplot
  ggplot(aes(x = StratumName, y = SquaredError, fill = Modeltype)) + 
  geom_boxplot() + theme_bw()
```
