---
title: "Umweltstatistik Bericht - R"
author: "Milena Mensching und Justus Weyers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
---

# Technisches

## Pakete laden

```{r, warning=FALSE, message=FALSE}
# Das Tidyverse
library(tidyverse)

# Plots
library(GGally)
library(corrplot)
library(patchwork)

# Statistik
library(Metrics)
library(rstatix)

# Geo-Pakete
library(sf)
library(tmap)

# Lineare Modelle
library(glmulti)
library(car) # vif
library(visreg)

# Baumbasierte Modelle
library(tree)
library(randomForest)
library(quantregForest)

# LaTex
library(xtable)
```

## Einstellungen

```{r, warning = FALSE, message=FALSE}
# Seed festlegen
set.seed(1)
# Kartenansicht auf interaktiv einstellen
tmap::tmap_mode("view")
```

## Funktionsdefinitionen

```{r}
# Funktion, um Modellvorhersage und Fehler an 
# den zentralen Dataframe 'data' anzubinden
pred = function(name, model, predictors = NA, data, response, 
                predictions = NULL) {
  # Vorhersagespalte anlegen
  data[,name] = rep(NA, nrow(data))
  # Fehlerspalte anlegen
  data[,paste0("err", name)] = rep(NA, nrow(data))
    
  if (!is.null(predictions)) {
    data[as.double(names(predictions)),name] = predictions
  } else {
    # Vorhersagewerte bestimmen
    predictions = predict(model, newdata = predictors)
    
    # Vorhersage anbinden
    data[rownames(predictors),name] = predictions
  }
  
  # Eigentliche Werte 
  actual = data[!is.na(data[,name]), response]
  # Fehler anbinden
  data[!is.na(data[,name]),paste0("err", name)] = sqrt((predictions-actual)**2)
  
  return(data)
}

# Funktion zur Berechnung von Gesamtvarianz (SST), 
# nicht-erklärter Varianz (SSE) und R²
var = function(yobs, ymod) {
  SST = sum((yobs - mean(yobs))^2)
  SSE = sum((yobs - ymod)^2)
  R2 = 1-SSE/SST
  vec = setNames(c(SST, SSE, R2), c("SST", "SSE", "R2"))
  return(vec)
}

# Funktion, um aus einem Dataframe ein 
# simple feature zu erstellen
sf = function(df) {
  st_as_sf(df, coords = c("x_UTM", "y_UTM"), crs = st_crs(25833))
}

# Funktion um die Wichtigkeit von Prädiktoren 
# in einem linearen Modell 'x' zu erhalten
# Code: {glmulti} Vincent Calcagno, McGill University 
# (modifiziert)
getImportance = function(x) {
  # plots variable (i.e. terms) importances
	ww = exp(-(x@crits - x@crits[1])/2)
	ww=ww/sum(ww)
	# handle synonymies for interactions
	# this translates to unique notations (e.g. x:y and y:x are the same)
	clartou=function(x) {
		sort(strsplit(x, ":")[[1]])-> pieces
		if (length(pieces)>1) paste(pieces[1],":",pieces[2],sep="")
		else x
		}
	# list terms in models
	tet = lapply(x@formulas, function(x) sapply(attr(delete.response(terms(x)),"term.labels"), clartou))
	# all unique terms
	unique(unlist(tet))-> allt
	# importances
	sapply(allt, function(x) sum(ww[sapply(tet, function(t) x%in%t)]))-> imp
	return(imp)
}
```

## Konstanten

```{r}
# Inputdatei
inputdata = "Data/data.txt"
# Abbildungsordner
imgpath = "Images/"

# Response-Variable
response = "Bodenfeuchte_Prozent"
# Name der Response-Variable
responseName = "Bodenfeuchte [%]"

# Prädiktoren
predicts = c(
  "Tiefe_zum_Oxidationshorizont_cm",
  "Maechtigkeit_Oxidationshorizont_cm",
  "Maechtigkeit_A_Horizont_cm",
  "Maechtigkeit_AL_Schicht_cm",
  "Gelaendehoehe_m"
  )
# Namen der Prädiktoren
predictsNames = c(
  "Tiefe zum Oxidationshorizont [cm]",
  "Mächtigkeit Oxidationshorizont [cm]",
  "Mächtigkeit A-Horizont [cm]",
  "Mächtigkeit AL-Schicht [cm]",
  "Geländehöhe [m]"
  )
```

## Daten einlesen

```{r}
# Alles Einlesen
readin = read.table(inputdata, header = TRUE)

# Variablen von Interesse auswählen
data = readin |> 
  select(all_of(c("Punkt", "Jahr", "Stratum", "x_UTM", "y_UTM", 
                  predicts, response)))

# Neue Spalte anlegen mit Namen der Straten
data = data %>%
  mutate(StratumName = case_when(
    Stratum == 1 ~ "Talsand",
    Stratum == 2 ~ "Übergang",
    Stratum == 3 ~ "Feuchtwiese"
    ))
```

## Modelldaten selektieren

```{r}
modeldata =  data |> 
  select(all_of(c(predicts, response))) |> 
  na.omit()

# Prädiktoren selektieren
predictors = modeldata |> 
  select(-one_of(response))

# Kartenansicht der Daten
# tm_shape(sf(data)) + tm_dots(col = response)
```

# Datenexploration

```{r, warning = FALSE, message=FALSE}
# Korrelationsmatrix
corplot = ggpairs(modeldata, 
                  columnLabels = str_wrap(c(predictsNames, responseName), width = 10)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme_bw()
# Export als svg Datei
# svg(file.path(imgpath, "corplot.svg"), height=8,width=8)
# corplot
# dev.off()
  
# Test auf Normalverteiltheit
shapiro = modeldata |>
  # Shapiro-Wilk Test auf Normalverteiltheit
  shapiro_test(vars = c(predicts, response)) |>
  # Spalte anlegen: Normalverteilt Ja/Nein
  mutate(normal = p>0.05) |>
  # Umbenennung der rownames
  mutate(names = rev(c(predictsNames, responseName))) |>
  column_to_rownames('names') |>
  select(-variable)

# Ausgabe von 'shapiro' als LaTex-Tabelle
# shapiro|>
#   xtable()
```

# Lineare Modelle

## Einfaches lineares Modell

```{r}
# Modellerstellung
linModel = lm(Bodenfeuchte_Prozent ~ ., data = modeldata)

summary(linModel)
# Vorhersage und Fehler speichern
data = pred(name = "linModel", model = linModel, predictors = predictors, 
            data = data, response = response)
# RMSE
rmse(actual = data[!is.na(data$linModel), response], 
     predicted = data[!is.na(data$linModel), "linModel"])

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errlinModel~ data$StratumName) #p-value = 0.8407, Varianzen gleich
results = aov(errlinModel ~ StratumName, data=data)
summary(results) #P-value: 0.751 -> Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht

# VIF
{
out <- barplot(vif(linModel), main="", names.arg="")
text(out, rep(-.1, 6), c("Tiefe zum Ox.horizont", "Mächtigkeit Ox.horizont", "Mächtigkeit_A", "Mächtigkeit_AL", "Geländehöhe"), srt=45, pos=2, xpd=NA, cex=.75)
text(x = out, y= vif(linModel), 
     label = paste(round(vif(linModel),3)),
     pos = 1, cex = 0.8, col = "red")
}
# Alternativer VIF-Plot mit ggplot()
vifdf = data.frame(vif = vif(linModel), predictors = predictsNames)
vifdf |>
  ggplot(aes(x = predictors, y = vif)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = format(round(vif, 2))), vjust = -0.3, size = 3.5)+
  labs(x = "Prädiktoren", y = "VIF")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw()

# Barplot zur Cooks-Distance
plot(linModel, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cook´sche Distanz")
text(x= 40, y= 0.3,label = "max = 0,326", pos = 4, cex = 0.8)
text(x= 40, y= 0.25,label = "mean = 0,023", pos = 4,cex = 0.8)
text(x= 40, y= 0.2,label = "min = 6,00e-05", pos = 4, cex = 0.8)

max(cooks.distance(linModel)) #0.3255527
min(cooks.distance(linModel)) #6.002479e-05
mean(cooks.distance(linModel)) #0.02328232

# Model-Wert für das lineare Modell
AIC(linModel)

# Regressionsgeraden
p1 <- visreg(linModel, xvar = "Gelaendehoehe_m", gg= TRUE, ylab= "")
p2 <- visreg(linModel, xvar = "Tiefe_zum_Oxidationshorizont_cm", gg = TRUE, ylab = "")
p3 <- visreg(linModel, xvar = "Maechtigkeit_Oxidationshorizont_cm",gg = TRUE, ylab= "Bodenfeuchte[%]")
p4 <- visreg(linModel, xvar = "Maechtigkeit_A_Horizont_cm", gg = TRUE, ylab = "")
p5 <- visreg(linModel, xvar = "Maechtigkeit_AL_Schicht_cm", gg = TRUE, ylab="")
(p1+p2)/(p3+p4)/(p5+ plot_spacer())
```

## Bestes lineares Modell

```{r}
# Mögliche lineare Modelle nach Güte untersuchen und ordnen
res = glmulti(linModel, level = 1, method = "h", confsetsize = 8, crit = "AIC")

# AICs der ersten 8 Modelle
plot(res)
mean(res@crits)

# Wichtigkeit von Prädiktoren
imp = data.frame(importance = getImportance(res))
imp |> 
  ggplot(aes(x = importance, y = reorder(rownames(imp), importance))) +
  geom_bar(stat="identity") +
  geom_vline(xintercept = 0.8, color = "red") +
  labs(x = "", y = "") +
  theme_bw()

# Das beste Modell extrahieren
bestlinModel = res@objects[[1]]
# Beschreibung des besten Modells
summary(bestlinModel)
# Defaut Plots 
plot(bestlinModel)
# AIC des besten linearen Modells
res@crits[1]

# Vorhersage und Fehler speichern
data = pred(name = "bestlinModel", model = bestlinModel, 
            predictors = predictors, data = data, 
            response = response)
# Varianz
var(yobs = data[!is.na(data$bestlinModel), response], 
    ymod = na.omit(data$bestlinModel))
# RMSE
rmse(actual = data[!is.na(data$bestlinModel), response], 
     predicted = data[!is.na(data$bestlinModel), "bestlinModel"])

#Cooks Distance

plot(bestlinModel, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cook´sche Distanz")
text(x= 40, y= 0.2,label = "max = 0,199", pos = 4, cex = 0.8)
text(x= 40, y= 0.18,label = "mean = 0,022", pos = 4,cex = 0.8)
text(x= 40, y= 0.16,label = "min = 5,37e-05", pos = 4, cex = 0.8)

max(cooks.distance(bestlinModel)) #0.1993562
min(cooks.distance(bestlinModel)) #5.374797e-06
mean(cooks.distance(bestlinModel)) #0.02204445

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errbestlinModel~ data$StratumName) #p-value = 0.9685, Varianzen gleich
results = aov(errbestlinModel ~ StratumName, data=data)
summary(results) #P-value: 0.55 -> Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```

## Plots Lineare Modelle

```{r}
# Vorhersage Einfaches lineares Model
ggplot(data |> drop_na(linModel), aes(x = Bodenfeuchte_Prozent, y = linModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()

# Fehler ~ Stratum
ggplot(data |> drop_na(errlinModel), aes(x = StratumName, y = errlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten")+
  theme(legend.position="none") +
  theme_bw()

# Vorhersage bestes lineares Model
ggplot(data |> drop_na(bestlinModel), aes(x = Bodenfeuchte_Prozent, y = bestlinModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()

# Fehler ~ Stratum
ggplot(data |> drop_na(errbestlinModel), aes(x = StratumName, y = errbestlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten")+
  theme(legend.position="none") +
  theme_bw()
  
# tm_shape(sf(data)) + tm_dots(col = "bestlinModel")
```

# Baumbasierte Modelle

## CART

```{r}
# Baum erstellen
treeModel = tree(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "treeModel", model = treeModel, 
            predictors = predictors, data = data, 
            response = response)
# Baumplot
{plot(treeModel);text(treeModel)}
```

## Random Forest

```{r}
# Wald anlegen
randomForest = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata)

# OOB-INB Geschichte
oob = predict(randomForest)
data = pred(name = "OOB", predictions = oob, data = data, response = response)

inb = predict(randomForest, newdata = predictors)
data = pred(name = "INB", predictions = inb, data = data, response = response)

var(yobs = data[!is.na(data$OOB), response], ymod = na.omit(data$OOB))
var(yobs = data[!is.na(data$INB), response], ymod = na.omit(data$INB))

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("OOB", "INB"), names_to='Vorhersagetyp', 
               values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Vorhersagetyp)) +
  geom_point() +
  scale_color_manual(values = c("palegreen4", "palegreen2")) +
  theme_bw()

# Variableneinfluss
importance = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata, 
                          importance = TRUE)
varImpPlot(importance, type = "1")
```

# Diskussion

## Vergleich Fehler 

Vergleich der Fehler der verwendeten Modelle in Abhängigkeit vom Stratum.

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("errlinModel", "errbestlinModel", "errtreeModel", 
                      "errOOB", "errINB"), 
               names_to='Modeltype', values_to='RootsquaredError') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(RootsquaredError) |>
  # ggplot
  ggplot(aes(x = StratumName, y = RootsquaredError, fill = Modeltype)) + 
  # Plot-Elemente
  geom_boxplot() + 
  # Beschriftung
  scale_fill_discrete(labels=c("Bestes lineares Modell", "RF-INB", 
                               "Einfaches lineares Modell", "RF-OOB", "CART")) +
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme", fill = "Modelltyp") +
  # Theme
  theme_bw()
```

Vergleich der Abweichung von der Diagonalen

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("linModel", "bestlinModel", "treeModel", "OOB", "INB"), 
               names_to='Modeltype', values_to='predictions') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(predictions) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = predictions, colour = Modeltype)) + 
  # Plot Elemente
  geom_point(aes(color = Modeltype)) + 
  geom_abline(slope = 1) + annotate("text", x = 13, y = 7, label = "y = 1x") +
  # Beschriftung
  labs(x = "Messwerte", y = "Vorhersage") +
  scale_color_discrete(name = "Modelltyp", 
                       breaks = c("bestlinModel", "INB", "linModel", 
                                  "OOB", "treeModel"), 
                       labels = c("Bestes lineares Modell", "RF-INB", 
                                  "Einfaches lineares Modell", "RF-OOB", 
                                  "CART")) +
  # Theme
  theme_bw()


```

# Finale

```{r, warning=FALSE}
# Abspeichern des data-Dataframes als csv-Datei
write.csv(data, file.path("Data", "DATA.csv"))
# Abspeichern des data-DAtaframes als shape-Datei
write_sf(sf(data), file.path("shapefiles", "points.shp"), delete_layer = TRUE)
```

