---
title: "Umweltstatistik Bericht - R"
author: "Milena Mensching und Justus Weyers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
---

# Technisches

## Pakete laden

```{r, warning=FALSE, message=FALSE}
# Das Tidyverse
library(tidyverse)

# Plots
library(GGally)
library(corrplot)
library(patchwork)


# Statistik
library(Metrics)

# Geo-Pakete
library(sf)
library(tmap)

# Lineare Modelle
library(glmulti)
library(car) # vif
library(visreg)

# Baumbasierte Modelle
#install.packages("tree")
#install.packages("quantregForest")
library(tree)
library(randomForest)
library(quantregForest)
```

## Einstellungen

```{r, warning = FALSE, message=FALSE}
# Seed festlegen
set.seed(1)
# Kartenansicht auf interaktiv einstellen
tmap::tmap_mode("view")
```

## Funktionsdefinitionen

```{r}
# Funktion, um Modellvorhersage und Fehler an 
# den zentralen Dataframe 'data' anzubinden
pred = function(name, model, predictors = NA, data, response, 
                predictions = NULL) {
  # Vorhersagespalte anlegen
  data[,name] = rep(NA, nrow(data))
  # Fehlerspalte anlegen
  data[,paste0("err", name)] = rep(NA, nrow(data))
    
  if (!is.null(predictions)) {
    data[as.double(names(predictions)),name] = predictions
  } else {
    # Vorhersagewerte bestimmen
    predictions = predict(model, newdata = predictors)
    
    # Vorhersage anbinden
    data[rownames(predictors),name] = predictions
  }
  
  # Eigentliche Werte 
  actual = data[!is.na(data[,name]), response]
  # Fehler anbinden
  data[!is.na(data[,name]),paste0("err", name)] = sqrt((predictions - actual)**2)
  
  return(data)
}

# Funktion zur Berechnung von Gesamtvarianz (SST), 
# nicht-erklärter Varianz (SSE) und R²
var = function(yobs, ymod) {
  SST = sum((yobs - mean(yobs))^2)
  SSE = sum((yobs - ymod)^2)
  R2 = 1-SSE/SST
  vec = setNames(c(SST, SSE, R2), c("SST", "SSE", "R2"))
  return(vec)
}

# Funktion, um aus einem Dataframe ein 
# simple feature zu erstellen
sf = function(df) {
  st_as_sf(df, coords = c("x_UTM", "y_UTM"), crs = st_crs(25833))
}
```

## Daten einlesen

```{r}
# Inputdatei
path = "Data/data.txt"

# Response-Variable
response = "Bodenfeuchte_Prozent"

# Alles Einlesen
readin = read.table(path, header = TRUE)

# Variablen von Interesse auswählen
data = readin |> 
  select(Punkt, Jahr, Stratum, x_UTM, y_UTM,
         Tiefe_zum_Oxidationshorizont_cm, 
         Maechtigkeit_Oxidationshorizont_cm, 
         Maechtigkeit_A_Horizont_cm,
         Maechtigkeit_AL_Schicht_cm,
         Gelaendehoehe_m,
         Bodenfeuchte_Prozent)

# Modelldaten selektieren
modeldata =  data |> 
  select(Tiefe_zum_Oxidationshorizont_cm,
         Maechtigkeit_Oxidationshorizont_cm, 
         Maechtigkeit_A_Horizont_cm,
         Maechtigkeit_AL_Schicht_cm,
         Gelaendehoehe_m,
         Bodenfeuchte_Prozent) |> 
  na.omit()

# Prädiktoren selektieren
predictors = modeldata |> 
  select(-one_of(response))

# Kartenansicht der Daten
tm_shape(sf(data)) + tm_dots(col = response)
```

## Dataframe bearbeiten

Hier sind ein paar unabhängige Änderungen am Dataframe 'data' platziert.

```{r}
# Neue Spalte anlegen mit Namen der Straten
data = data %>%
  mutate(StratumName = case_when(
    Stratum == 1 ~ "Talsand",
    Stratum == 2 ~ "Übergang",
    Stratum == 3 ~ "Feuchtwiese"
    ))
```

# Datenexploration

```{r, warning = FALSE, message=FALSE}
# Korrelationsmatrix
# ggpairs(modeldata)

# Alternativ:
# cor_model = cor(modeldata, use = "pairwise.complete.obs")
# p_values = cor.mtest(modeldata, conf.level = 0.95)
# corrplot(cor_model, p.mat = p_values$p, insig = 'p-value', sig.level = -1)
```

# Lineare Modelle

## Einfaches lineares Modell

```{r}
# Modellerstellung
linModel = lm(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "linModel", model = linModel, predictors = predictors, 
            data = data, response = response)
# RMSE
rmse(actual = data[!is.na(data$linModel), response], 
     predicted = data[!is.na(data$linModel), "linModel"])

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errlinModel~ data$StratumName) #p-value = 0.8407, Varianzen gleich
results = aov(errlinModel ~ StratumName, data=data)
summary(results) #P-value: 0.751 -> Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht

# VIF
vif(linModel)
#barplot(vif(linModel), main="VIF", names.arg= "", horiz = T, las= 1, cex.names = 0.7)
#text(1.85, 5.5, "Geländehöhe (1,90)", pos = 4)
#text(1.45, 3,"Mächtigkeit_A_Horizont (1,50)", pos = 4)
#text(3,2, "Mächtigkeit_Ox.Horizont (3,00)", pos = 4)
#text("Mächtigkeit_AL_Horizont (1,72)")
#text("Tiefe zum Ox.Horizont (2,68")


out <- barplot(vif(linModel), main="", names.arg="")
text(out, rep(-.1, 6), c("Tiefe zum Ox.horizont", "Mächtigkeit Ox.horizont", "Mächtigkeit_A", "Mächtigkeit_AL", "Geländehöhe"), srt=45, pos=2, xpd=NA, cex=.75)
text(x = out, y= vif(linModel), 
     label = paste(round(vif(linModel),3)),
     pos = 1, cex = 0.8, col = "red")

barplot(cooks.distance(linModel), cex.names = 0.7, ylim = c(0, 0.4))
AIC(linModel)


p1 <- visreg(linModel, xvar = "Gelaendehoehe_m", gg= T, ylab= "")
p2 <- visreg(linModel, xvar = "Tiefe_zum_Oxidationshorizont_cm", gg = T, ylab = "")
p3 <- visreg(linModel, xvar = "Maechtigkeit_Oxidationshorizont_cm",gg = T, ylab= "Bodenfeuchte[%]")
p4 <- visreg(linModel, xvar = "Maechtigkeit_A_Horizont_cm", gg = T, ylab = "")
p5 <- visreg(linModel, xvar = "Maechtigkeit_AL_Schicht_cm", gg = T, ylab="")

(p1+p2)/(p3+p4)/(p5+ plot_spacer())
```

## Bestes lineares Modell

```{r}
# Mögliche lineare Modelle nach Güte untersuchen und ordnen
res = glmulti(linModel, level = 1, method = "h", confsetsize = 8, crit = "AIC")

res1 = glmulti(linModel, level = 1, method = "h", confsetsize = 1, crit = "AIC")
# AICs
plot(res)
mean(res@crits)


# Wichtigkeit von Prädiktoren
plot(res, type = "s")

# Das beste Modell
bestlinModel = res@objects[[1]]
summary(bestlinModel)
plot(bestlinModel)
res1@crits #AIC

#linModelattempt= lm(Bodenfeuchte_Prozent ~ Gelaendehoehe_m + #Tiefe_zum_Oxidationshorizont_cm, data = modeldata)
#summary(linModelattempt)
#visreg(linModelattempt) SO geht es, das Modell darzustellen, aber andddererseites sind die gleichen Abbildungen ja logischerweise auch in den Visualisierungen des einfachen linearen Modells


# Vorhersage und Fehler speichern
data = pred(name = "bestlinModel", model = bestlinModel, 
            predictors = predictors, data = data, 
            response = response)
var(yobs = data[!is.na(data$bestlinModel), response], ymod = na.omit(data$bestlinModel))
# RMSE
rmse(actual = data[!is.na(data$bestlinModel), response], 
     predicted = data[!is.na(data$bestlinModel), "bestlinModel"])
```

## Plots Lineare Modelle

```{r}
# Einfaches lineares Model
ggplot(data |> drop_na(linModel), aes(x = Bodenfeuchte_Prozent, y = linModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", caption = "Bodenfeuchte [%]", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x")

ggplot(data |> drop_na(errlinModel), aes(x = StratumName, y = errlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme")+
   theme(legend.position="none")

# Bestes lineares Model
ggplot(data |> drop_na(bestlinModel), aes(x = Bodenfeuchte_Prozent, y = bestlinModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", caption = "Bodenfeuchte [%]", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x")

ggplot(data |> drop_na(errbestlinModel), aes(x = StratumName, y = errbestlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme")+
   theme(legend.position="none")
  

tm_shape(sf(data)) + tm_dots(col = "bestlinModel")
```

# Baumbasierte Modelle

## CART

```{r}
# Baum erstellen
treeModel = tree(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "treeModel", model = treeModel, 
            predictors = predictors, data = data, 
            response = response)
# Baumplot
{plot(treeModel);text(treeModel)}
```

## Random Forest

```{r}
# Wald anlegen
randomForest = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata)

# OOB-INB Geschichte
oob = predict(randomForest)
data = pred(name = "OOB", predictions = oob, data = data, response = response)

inb = predict(randomForest, newdata = predictors)
data = pred(name = "INB", predictions = inb, data = data, response = response)

var(yobs = data[!is.na(data$OOB), response], ymod = na.omit(data$OOB))
var(yobs = data[!is.na(data$INB), response], ymod = na.omit(data$INB))

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("OOB", "INB"), names_to='Vorhersagetyp', 
               values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Vorhersagetyp)) +
  geom_point() +
  scale_color_manual(values = c("palegreen4", "palegreen2")) +
  theme_bw()

# Variableneinfluss
importance = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata, 
                          importance = TRUE)
varImpPlot(importance, type = "1")
```

# Diskussion

## Vergleich Fehler 

Vergleich der Fehler der verwendeten Modelle in Abhängigkeit vom Stratum.

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("errlinModel", "errbestlinModel", "errtreeModel", "errOOB", "errINB"), 
               names_to='Modeltype', values_to='RootsquaredError') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(RootsquaredError) |>
  # ggplot
  ggplot(aes(x = StratumName, y = RootsquaredError, fill = Modeltype)) + 
  geom_boxplot() + theme_bw()+
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme", fill = "Modelltyp")+
   scale_fill_discrete(labels=c("Bestes lineares Modell", "RF-INB", "Einfaches lineares Modell", "RF-OOB", "CART"))
```

Vergleich der Abweichung von der Diagonalen
```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("linModel", "bestlinModel", "treeModel", "OOB", "INB"), 
               names_to='Modeltype', values_to='predictions') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(predictions) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = predictions, colour = Modeltype)) + 
  geom_line(aes(color = Modeltype)) + theme_bw()+
  labs(x = "Messwerte", y = "Vorhersage") +
  scale_color_discrete(name = "Modelltyp", breaks = c("bestlinModel", "INB", "linModel", "OOB", "treeModel"), labels=c("Bestes lineares Modell", "RF-INB", "Einfaches lineares Modell", "RF-OOB", "CART"))+
  geom_abline(slope = 1) + annotate("text", x = 13, y = 7, label = "y = 1x")


```
