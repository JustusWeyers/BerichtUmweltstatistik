---
title: "Umweltstatistik Bericht - R"
author: "Milena Mensching und Justus Weyers"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
---

# Technisches

## Pakete laden

```{r, warning=FALSE, message=FALSE}
# Das Tidyverse
library(tidyverse)

# Plots
library(GGally)
library(corrplot)
library(patchwork)

# Statistik
library(Metrics)
library(rstatix)

# Geo-Pakete
library(sf)
library(tmap)

# Lineare Modelle
library(glmulti)
library(car)
library(visreg)

# Baumbasierte Modelle
library(tree)
library(rpart)
library(rpart.plot)
library(randomForest)
library(quantregForest)

# LaTex
library(xtable)
```

## Einstellungen

```{r, warning = FALSE, message=FALSE}
# Seed festlegen
set.seed(1)
# Kartenansicht auf interaktiv einstellen
tmap::tmap_mode("view")
```

## Funktionsdefinitionen

```{r}
# Funktion, um Modellvorhersage und Fehler an 
# den zentralen Dataframe 'data' anzubinden
pred = function(name, model, predictors = NA, data, response, 
                predictions = NULL) {
  # Vorhersagespalte anlegen
  data[,name] = rep(NA, nrow(data))
  # Fehlerspalte anlegen
  data[,paste0("err", name)] = rep(NA, nrow(data))
    
  if (!is.null(predictions)) {
    data[as.double(names(predictions)),name] = predictions
  } else {
    # Vorhersagewerte bestimmen
    predictions = predict(model, newdata = predictors)
    
    # Vorhersage anbinden
    data[rownames(predictors),name] = predictions
  }
  
  # Eigentliche Werte 
  actual = data[!is.na(data[,name]), response]
  # Fehler anbinden
  data[!is.na(data[,name]),paste0("err", name)] = sqrt((predictions-actual)**2)
  
  return(data)
}

# Funktion zur Berechnung von Gesamtvarianz (SST), 
# nicht-erklärter Varianz (SSE) und R²
var = function(yobs, ymod) {
  SST = sum((yobs - mean(yobs))^2)
  SSE = sum((yobs - ymod)^2)
  R2 = 1-SSE/SST
  vec = setNames(c(SST, SSE, R2), c("SST", "SSE", "R2"))
  return(vec)
}

# Funktion, um aus einem Dataframe ein 
# simple feature zu erstellen
sf = function(df) {
  st_as_sf(df, coords = c("x_UTM", "y_UTM"), crs = st_crs(25833))
}

# Funktion um die Wichtigkeit von Prädiktoren 
# in einem linearen Modell 'x' zu erhalten
# Code: {glmulti} Vincent Calcagno, McGill University 
# (modifiziert)
getImportance = function(x) {
  # plots variable (i.e. terms) importances
	ww = exp(-(x@crits - x@crits[1])/2)
	ww=ww/sum(ww)
	# handle synonymies for interactions
	# this translates to unique notations (e.g. x:y and y:x are the same)
	clartou=function(x) {
		sort(strsplit(x, ":")[[1]])-> pieces
		if (length(pieces)>1) paste(pieces[1],":",pieces[2],sep="")
		else x
		}
	# list terms in models
	tet = lapply(x@formulas, function(x) sapply(attr(delete.response(terms(x)),"term.labels"), clartou))
	# all unique terms
	unique(unlist(tet))-> allt
	# importances
	sapply(allt, function(x) sum(ww[sapply(tet, function(t) x%in%t)]))-> imp
	return(imp)
}

# Funktionen um Daten mit Hilfe der 
# Box-Cox-Transformation zu transformieren
BCTransform <- function(y, lambda=0) {
    if (lambda == 0L) { log(y) }
    else { (y^lambda - 1) / lambda }
}
BCTransformInverse <- function(yt, lambda=0) {
    if (lambda == 0L) { exp(yt) }
    else { exp(log(1 + lambda * yt)/lambda) }
}
```

## Konstanten

```{r}
# Inputdatei
inputdata = "Data/data.txt"
# Abbildungsordner
imgpath = "Images/"

# Response-Variable
response = "Bodenfeuchte_Prozent"
# Name der Response-Variable
responseName = "Bodenfeuchte [%]"

# Prädiktoren
predicts = c(
  "Tiefe_zum_Oxidationshorizont_cm",
  "Maechtigkeit_Oxidationshorizont_cm",
  "Maechtigkeit_A_Horizont_cm",
  "Maechtigkeit_AL_Schicht_cm",
  "Gelaendehoehe_m"
  )
# Namen der Prädiktoren
predictsNames = c(
  "Tiefe zum Oxidationshorizont [cm]",
  "Mächtigkeit Oxidationshorizont [cm]",
  "Mächtigkeit A-Horizont [cm]",
  "Mächtigkeit AL-Schicht [cm]",
  "Geländehöhe [m]"
  )
```

## Daten einlesen

```{r}
# Alles Einlesen
readin = read.table(inputdata, header = TRUE)

# Variablen von Interesse auswählen
data = readin |>
  select(all_of(c("Punkt", "Jahr", "Stratum", "x_UTM", "y_UTM", 
                   predicts, response)))

# Neue Spalte anlegen mit Namen der Straten
data = data %>%
  mutate(StratumName = case_when(
    Stratum == 1 ~ "Talsand",
    Stratum == 2 ~ "Übergang",
    Stratum == 3 ~ "Feuchtwiese"
    ))
```

## Modelldaten selektieren

```{r}
# Daten für die Modellerstellung
modeldata =  data |> 
  select(all_of(c(predicts, response))) |> 
  na.omit()

# Daten für die Untersuchung auf Korrelation
cordata = data |>
  select(all_of(c(predicts, response, "StratumName"))) |> 
  mutate(StratumName = as.factor(StratumName)) |>
  na.omit()

# Prädiktoren selektieren
predictors = modeldata |> 
  select(-one_of(response))

# Kartenansicht der Daten
# tm_shape(sf(data)) + tm_dots(col = response)
```

# Datenexploration

## Korrelationsuntersuchung

```{r, warning = FALSE, message=FALSE}
# Korrelationsmatrix
corplot = ggpairs(cordata, aes(colour = StratumName, alpha = 0.4)) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  theme_bw()

# Export von 'corplot' als SVG
{svg(file.path(imgpath, "corplot.svg"), height=8,width=8);corplot;dev.off()}
```

## Verteilung der Daten

```{r, warning = FALSE, message=FALSE}
# Test auf Normalverteiltheit
shapiro = modeldata |>
  # Shapiro-Wilk Test auf Normalverteiltheit
  shapiro_test(vars = c(predicts, response)) |>
  # Spalte anlegen: Normalverteilt Ja/Nein
  mutate(normal = p>0.05) |>
  # Umbenennung der rownames
  mutate(names = rev(c(predictsNames, responseName))) |>
  column_to_rownames('names') |>
  select(-variable)

# Ausgabe von 'shapiro' als LaTex-Tabelle
# shapiro |> xtable()
```

# Einfaches lineares Modell

## Modellerstellung

```{r}
# Modellerstellung
linModel = lm(Bodenfeuchte_Prozent ~ ., data = modeldata)

# Vorhersage und Fehler speichern
data = pred(name = "linModel", model = linModel, predictors = predictors, 
            data = data, response = response)
```

## Modellbewertung

```{r}
plot(linModel)
reslin <- resid(linModel)
plot(density(reslin))
# Modellbeschreibung
summary(linModel)

# Model-Wert für das lineare Modell
AIC(linModel)

# RMSE
rmse(actual = data[!is.na(data$linModel), response], 
     predicted = data[!is.na(data$linModel), "linModel"])

# Varianz
var(yobs = data[!is.na(data$linModel), response], 
    ymod = na.omit(data$linModel))

# VIF
# Base-R plot
{par(mar = c(3, 15, 1, 1)); barplot(vif(linModel), horiz = TRUE, las = 2)}
# ggplot
vifdf = data.frame(vif = vif(linModel), predictors = predictsNames)
vifdf |>
  ggplot(aes(x = predictors, y = vif)) +
  geom_bar(stat = "identity", fill = "white", col = "black") +
  geom_text(aes(label = format(round(vif, 2))), vjust = -0.3, size = 3.5)+
  labs(x = "Prädiktoren", y = "VIF")+
  scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) +
  theme_bw()

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errlinModel~ data$StratumName)
# => p-value = 0.8407: Varianzen gleich
results = aov(errlinModel ~ StratumName, data=data)
summary(results) 
# => p-value: 0.751: Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```

## Visualisierung

```{r}
# Vorhersage Einfaches lineares Modell
ggplot(data |> drop_na(linModel), aes(x = Bodenfeuchte_Prozent, y = linModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()

# Fehler ~ Stratum
ggplot(data |> drop_na(errlinModel), aes(x = StratumName, y = errlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten", fill = "Stratum")+
  theme(legend.position="none") +
  theme_bw()

# Barplot zur Cooks-Distance
plot(linModel, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cook´sche Distanz")
text(x= 40, y= 0.3,label = "max = 0,326", pos = 4, cex = 0.8)
text(x= 40, y= 0.25,label = "mean = 0,023", pos = 4,cex = 0.8)
text(x= 40, y= 0.2,label = "min = 6,00e-05", pos = 4, cex = 0.8)

max(cooks.distance(linModel)) #0.3255527
min(cooks.distance(linModel)) #6.002479e-05
mean(cooks.distance(linModel)) #0.02328232

# Regressionsgeraden
p1 <- visreg(linModel, xvar = "Gelaendehoehe_m", gg= TRUE, ylab= "")
p2 <- visreg(linModel, xvar = "Tiefe_zum_Oxidationshorizont_cm", gg = TRUE, ylab = "")
p3 <- visreg(linModel, xvar = "Maechtigkeit_Oxidationshorizont_cm",gg = TRUE, ylab= "Bodenfeuchte[%]")
p4 <- visreg(linModel, xvar = "Maechtigkeit_A_Horizont_cm", gg = TRUE, ylab = "")
p5 <- visreg(linModel, xvar = "Maechtigkeit_AL_Schicht_cm", gg = TRUE, ylab="")
(p1+p2)/(p3+p4)/(p5+ plot_spacer())
```

# Autom. Modellselektion

## Modellerstellung

```{r}
# Mögliche lineare Modelle nach Güte untersuchen und ordnen
res = glmulti(linModel, level = 1, method = "h", confsetsize = 8, crit = "AIC")
# Das beste Modell übernehmen
bestlinModel = res@objects[[1]]
# Vorhersage und Fehler speichern
data = pred(name = "bestlinModel", model = bestlinModel, 
            predictors = predictors, data = data, 
            response = response)
```


## Modellbewertung

```{r}
# Beschreibung des besten Modells
summary(bestlinModel)

# AIC des besten linearen Modells
res@crits[1]
# AICs der ersten 8 Modelle
plot(res)
mean(res@crits)

# Varianz
var(yobs = data[!is.na(data$bestlinModel), response], 
    ymod = na.omit(data$bestlinModel))
# RMSE
rmse(actual = data[!is.na(data$bestlinModel), response], 
     predicted = data[!is.na(data$bestlinModel), "bestlinModel"])

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errbestlinModel~ data$StratumName) 
# => p-value = 0.9685: Varianzen gleich
results = aov(errbestlinModel ~ StratumName, data=data)
summary(results) 
# => p-value: 0.55: Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```

## Visualisierung

```{r}
# Default Plots 
# plot(bestlinModel)

# Vorhersage bestes lineares Model
ggplot(data |> drop_na(bestlinModel), aes(x = Bodenfeuchte_Prozent, y = bestlinModel))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()

# Fehler ~ Stratum
ggplot(data |> drop_na(errbestlinModel), aes(x = StratumName, y = errbestlinModel)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten")+
  theme(legend.position="none") +
  theme_bw()

# Wichtigkeit von Prädiktoren
imp = data.frame(importance = getImportance(res))
imp |> 
  ggplot(aes(x = importance, y = reorder(rownames(imp), importance))) +
  geom_bar(stat="identity") +
  geom_vline(xintercept = 0.8, color = "red") +
  labs(x = "", y = "") +
  theme_bw()

#Cooks Distance
plot(bestlinModel, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cook´sche Distanz")
text(x= 40, y= 0.2,label = "max = 0,199", pos = 4, cex = 0.8)
text(x= 40, y= 0.18,label = "mean = 0,022", pos = 4,cex = 0.8)
text(x= 40, y= 0.16,label = "min = 5,37e-05", pos = 4, cex = 0.8)

max(cooks.distance(bestlinModel)) #0.1993562
min(cooks.distance(bestlinModel)) #5.374797e-06
mean(cooks.distance(bestlinModel)) #0.02204445
```

# GLM - LOG

```{r}
# Arbeitskopie von 'modeldata' erstellen
modeldata_transf = data.frame(modeldata)
mean(modeldata$Bodenfeuchte_Prozent)

# Box-Cox-Transformation der Response-Variable
bc = MASS::boxcox(linModel)
lambda = bc$x[which.max(bc$y)]
modeldata_transf$Bodenfeuchte_Prozent = BCTransform(y = modeldata_transf$Bodenfeuchte_Prozent, lambda = lambda)
mean(modeldata_transf$Bodenfeuchte_Prozent)

# Aufstellen eines GLM. Linkfunktion: log 
glm = glm(Bodenfeuchte_Prozent ~ ., data=modeldata_transf, family=gaussian(link = "log"))
summary(glm)
plot(glm)

# Rücktransformation der Response Variable und der Vorhersage
glm_predictions = BCTransformInverse(predict(glm, type="response"), lambda = lambda)

data = pred(name = "glm", predictions = glm_predictions, data = data, response = response)

var(yobs = data[!is.na(data$glm), "Bodenfeuchte_Prozent"], ymod = data[!is.na(data$glm), "glm"])

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("bestlinModel", "glm"), names_to='Modell', values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Modell)) +
  geom_point() +
  scale_color_manual(values = c("palegreen4", "palegreen2")) +
  theme_bw()
```
## Modellbewertung

```{r}
# Beschreibung des GLMs
summary(glm)

# AIC des GLMS
AIC(glm)

# RMSE
rmse(actual = data[!is.na(data$glm), response], 
     predicted = data[!is.na(data$glm), "glm"])

# Varianz
var(yobs = data[!is.na(data$glm), response], 
    ymod = na.omit(data$glm))

# RMSE
rmse(actual = data[!is.na(data$glm), response], 
     predicted = data[!is.na(data$glm), "glm"])

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errglm~ data$StratumName) 
# => p-value = 0.1639: Varianzen gleich
results = aov(errglm ~ StratumName, data=data)
summary(results)
# p-value = 0.171 Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```
# GLM - GAMMA

```{r}
# Aufstellen eines GLM. Linkfunktion: gamma
glm_gamma = glm(Bodenfeuchte_Prozent ~ ., data=modeldata_transf, family= gaussian(link = "inverse"))
summary(glm_gamma)
plot(glm_gamma)

# Rücktransformation der Response Variable und der Vorhersage
glm_gamma_predictions = BCTransformInverse(predict(glm_gamma, type="response"), lambda = lambda)

data = pred(name = "glm_gamma", predictions = glm_gamma_predictions, data = data, response = response)
var(yobs = data[!is.na(data$glm_gamma), "Bodenfeuchte_Prozent"], ymod = data[!is.na(data$glm_gamma), "glm_gamma"])

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("bestlinModel", "glm", "glm_gamma"), names_to='Modell', values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Modell)) +
  geom_point() +
  scale_color_manual(values = c("lightblue", "palegreen4", "palegreen2")) +
  theme_bw()
```

## Modellbewertung

```{r}
# Beschreibung des GLMs
summary(glm_gamma)

# AIC des GLMS
AIC(glm_gamma)

# RMSE
rmse(actual = data[!is.na(data$glm_gamma), response], 
     predicted = data[!is.na(data$glm_gamma), "glm_gamma"])

# Varianz
var(yobs = data[!is.na(data$glm_gamma), response], 
    ymod = na.omit(data$glm_gamma))

#Cook´s Distance
plot(glm_gamma, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cook´sche Distanz")
text(x= 33, y= 0.09,label = "max = 0,101", pos = 4, cex = 0.8)
text(x= 33, y= 0.08,label = "mean = 0,019", pos = 4,cex = 0.8)
text(x= 33, y= 0.07,label = "min = 9,22e-07", pos = 4, cex = 0.8)

max(cooks.distance(glm_gamma)) #0.1013789
min(cooks.distance(glm_gamma)) #9.217823e-07
mean(cooks.distance(glm_gamma))#0.0185927

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errglm_gamma~ data$StratumName) 
# =>p-value = 0.2924: Varianzen gleich
results = aov(errglm_gamma ~ StratumName, data=data)
summary(results)
# p-value = 0.437 Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```
## Visualisierung
```{r}
ggplot(data |> drop_na(glm_gamma), aes(x = Bodenfeuchte_Prozent, y = glm_gamma))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  ylim(10,85)+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()

#Fehler ~ Stratum
ggplot(data |> drop_na(errglm_gamma), aes(x = StratumName, y = errglm_gamma)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten", fill = "Stratum")+
  theme(legend.position="none") +
  theme_bw()
```


# Automatisierte generalisierte Modellselektion

## Modellerstellung
```{r}
# Mögliche GLMs nach Güte untersuchen und ordnen
resglm = glmulti(glm_gamma, level = 1, method = "h", confsetsize = 8, crit = "AIC")
# Das beste Modell übernehmen
bestglm = resglm@objects[[1]]
# Vorhersage
bestglm_pred = BCTransformInverse(predict(bestglm, newdata = predictors), lambda = lambda)
# Speichern und Fehlerberechnung
data = pred(name = "bestglm", predictions = bestglm_pred, data = data, response = response)
```

## Modellbewertung

```{r}
# Beschreibung des besten GLMs
summary(bestglm)

# AIC des besten GLMs
resglm@crits[1]
# AICs der ersten 8 Modelle
plot(resglm)
mean(resglm@crits)

# Varianz
var(yobs = data[!is.na(data$bestglm), response], 
    ymod = na.omit(data$bestglm))
# RMSE
rmse(actual = data[!is.na(data$bestglm), response], 
     predicted = data[!is.na(data$bestglm), "bestglm"])

#Cook´s Distance
plot(bestglm, 4, main = "", xaxt = "n", ann = F)
title(xlab="Datenpunkt", ylab ="Cooksche Distanz")
text(x= 37, y= 0.13,label = "max = 0,152", pos = 4, cex = 0.8)
text(x= 37, y= 0.12,label = "mean = 0,021", pos = 4,cex = 0.8)
text(x= 37, y= 0.11,label = "min = 9,41e-05", pos = 4, cex = 0.8)

max(cooks.distance(bestglm)) #0.1523492
min(cooks.distance(bestglm)) #9.41153e-05
mean(cooks.distance(bestglm)) #0.02075966

#ANOVA für Testung, ob sich Vorhersagen für Straten unterscheiden
bartlett.test(data$errbestglm~ data$StratumName) 
# => p-value = 0.305: Varianzen gleich
results =aov(data$errbestglm~data$StratumName)
summary(results)
# p-value = 0.123 Ergebnis nicht signifikant, Vorhersagen unterscheiden sich nicht
```
## Visualisierung 

```{r}
# Wichtigkeit von Prädiktoren
imp = data.frame(importance = getImportance(resglm))
imp |> 
  ggplot(aes(x = importance, y = reorder(rownames(imp), importance))) +
  geom_bar(stat="identity") +
  geom_vline(xintercept = 0.8, color = "red") +
  labs(x = "", y = "") +
  theme_bw()



ggplot(data |> drop_na(bestglm), aes(x = Bodenfeuchte_Prozent, y = bestglm))+
  geom_point(aes(col = StratumName))+
  labs(x = "Messwerte", y = "Vorhersage", colour = "Stratum")+
  ylim(10,85)+
  geom_abline(slope = 1) + annotate("text", x = 52, y = 45, label = "y = 1x") +
  theme_bw()



#Fehler ~ Stratum
ggplot(data |> drop_na(errbestglm), aes(x = StratumName, y = errbestglm)) +
  geom_boxplot(aes(fill = StratumName)) +
  labs(x = "", y = "Wurzel aus Fehlerquadraten", fill = "Stratum")+
  theme(legend.position="none") +
  theme_bw()

```
# Visualisierung Vergleich lineare Modelle

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("linModel", 
                      "bestlinModel", 
                      "glm_gamma", 
                      "bestglm"), 
               names_to='Modeltype', values_to='predictions') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(predictions) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = predictions, colour = Modeltype)) + 
  # Plot Elemente
  geom_point(aes(color = Modeltype)) + 
  geom_abline(slope = 1) + annotate("text", x = 13, y = 7, label = "y = 1x") +
  # Beschriftung
  labs(x = "Messwerte", y = "Vorhersage") +
  # Theme
  theme_bw()



data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("errlinModel", 
                      "errbestlinModel",
                      "errglm_gamma",
                      "errbestglm",
                      ), 
               names_to='Modeltype', values_to='RootsquaredError') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(RootsquaredError) |>
  # ggplot
  ggplot(aes(x = StratumName, y = RootsquaredError, fill = Modeltype)) + 
  # Plot-Elemente
  geom_boxplot() + 
  # Beschriftung
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme", fill = "Modelltyp") +
  scale_fill_discrete(labels = c("Selektiertes GLM", "Selektiertes LM", "GLM", "LM"))+
  # Theme
  theme_bw()



```

# CART

```{r}
# Baum erstellen
treeModel <- rpart(Bodenfeuchte_Prozent ~ ., data = modeldata)
# Vorhersage und Fehler speichern
data = pred(name = "treeModel", model = treeModel, 
            predictors = predictors, data = data, 
            response = response)
# Baumplot
rpart.plot(treeModel, digits = 4)

# Stufen
modeldata %>%
  mutate(pred = predict(treeModel, modeldata)) %>%
  ggplot(aes(Gelaendehoehe_m, Bodenfeuchte_Prozent)) +
  geom_point(alpha = .2, size = 1) +
  geom_point(aes(Gelaendehoehe_m, y = Bodenfeuchte_Prozent), color = "blue", size = .75) +
  geom_line(aes(y = pred), color = "red", size = .75) +
  labs(x = "Geländehoehe [m]", y = "Bodenfeuchte [%]") +
  theme_bw()

data  |> 
  drop_na(treeModel) |>
  ggplot(aes(x = Bodenfeuchte_Prozent, y = treeModel, col = Gelaendehoehe_m)) +
  geom_point() +
  labs(x = "Messwerte Bodenfeuchte [%]", y = "Vorhersage Entscheidungsbaum") +
  scale_color_continuous(name = "Geländehöhe [m]", low = "forestgreen", high = "burlywood2") +
  theme_bw()
```

# Random Forest

```{r}
# Wald anlegen
randomForest = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata)

# OOB-INB Geschichte
oob = predict(randomForest)
data = pred(name = "OOB", predictions = oob, data = data, response = response)

inb = predict(randomForest, newdata = predictors)
data = pred(name = "INB", predictions = inb, data = data, response = response)

var(yobs = data[!is.na(data$OOB), response], ymod = na.omit(data$OOB))
var(yobs = data[!is.na(data$INB), response], ymod = na.omit(data$INB))

data |> 
  # Dataframe umgestalten. Spalte mit OOB/INB hinzufügen.
  pivot_longer(cols=c("OOB", "INB"), names_to='Vorhersagetyp', 
               values_to='Prediction') |>
  # Zeilen ohne vorhersagewerte löschen
  drop_na(Prediction) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = Prediction, col = Vorhersagetyp)) +
  geom_point() +
  scale_color_manual(values = c("palegreen4", "palegreen2")) +
  theme_bw()

# Variableneinfluss
importance = randomForest(Bodenfeuchte_Prozent ~ ., data = modeldata, 
                          importance = TRUE)
varImpPlot(importance, type = "1")
```

# Diskussion

## Vergleich Fehler 

Vergleich der Fehler der verwendeten Modelle in Abhängigkeit vom Stratum.

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("errlinModel", 
                      "errbestlinModel",
                      "errglm", 
                      "errglm_gamma",
                      "errbestglm",
                      "errtreeModel", 
                      "errINB"
                      ), 
               names_to='Modeltype', values_to='RootsquaredError') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(RootsquaredError) |>
  # ggplot
  ggplot(aes(x = StratumName, y = RootsquaredError, fill = Modeltype)) + 
  # Plot-Elemente
  geom_boxplot() + 
  # Beschriftung
  labs(x = "", y = "Wurzel aus Fehlerquadratsumme", fill = "Modelltyp") +
  # Theme
  theme_bw()
```

Vergleich der Abweichung von der Diagonalen.

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c("linModel", 
                      "bestlinModel", 
                      "glm", 
                      "glm_gamma", 
                      "treeModel", 
                      "INB", 
                      "bestglm"), 
               names_to='Modeltype', values_to='predictions') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(predictions) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = predictions, colour = Modeltype)) + 
  # Plot Elemente
  geom_point(aes(color = Modeltype)) + 
  geom_abline(slope = 1) + annotate("text", x = 13, y = 7, label = "y = 1x") +
  # Beschriftung
  labs(x = "Messwerte", y = "Vorhersage") +
  # Theme
  theme_bw()
```

```{r}
data |> 
  # Dataframe umgestalten. Spalte mit modelltyp hinzufügen.
  pivot_longer(cols=c( "bestlinModel", 
                       "bestglm"), 
               names_to='Modeltype', values_to='predictions') |>
  # Entfernen von Zeilen mit NAs in der Error-Spalte
  drop_na(predictions) |>
  # ggplot
  ggplot(aes(x = Bodenfeuchte_Prozent, y = predictions, colour = Modeltype)) + 
  # Plot Elemente
  geom_point(aes(color = Modeltype)) + 
  geom_abline(slope = 1) + annotate("text", x = 13, y = 7, label = "y = 1x") +
  # Beschriftung
  labs(x = "Messwerte", y = "Vorhersage") +
  # Theme
  theme_bw()
```




# Finale

```{r, warning=FALSE}
# Abspeichern des data-Dataframes als csv-Datei
write.csv(data, file.path("Data", "DATA.csv"))
# Abspeichern des data-DAtaframes als shape-Datei
write_sf(sf(data), file.path("shapefiles", "points.shp"), delete_layer = TRUE)
```

